# **Project Roadmap**

Это дорожная карта развития проекта "Just Media Server", описывающая функционал по спринтам. Каждый спринт представляет собой логический блок работ, нацеленный на достижение конкретного результата.

## **Спринт 1: Прототип и Базовая Инфраструктура (Завершено)**

**Цель:** Создать работающий прототип с базовым UI, аутентификацией и имитацией асинхронной обработки, заложив основу для медиа-сервера.

*   **Коммит 1.1: `feat(project): initial setup with Nuxt 3, Prisma, Tailwind`**
    *   Настроена базовая структура проекта Nuxt 3.
    *   Интегрирован `docker-compose.yml` с сервисами: PostgreSQL, Redis, MinIO.
    *   Настроена ORM Prisma и создана первоначальная миграция БД.
    *   Реализована базовая структура страниц и компонентов с использованием TailwindCSS.

*   **Коммит 1.2: `feat(auth): implement user authentication`**
    *   Реализованы модели `User` и `Role` в схеме Prisma.
    *   Созданы API-эндпоинты для регистрации и логина (`/api/v1/auth/...`).
    *   Интегрирована аутентификация на основе JWT.
    *   Создан `useAuth` composable для управления состоянием пользователя на клиенте.
    *   Реализованы серверные и клиентские middleware для защиты роутов.

*   **Коммит 1.3: `feat(admin): create basic content management`**
    *   Реализованы модели `Series`, `Season`, `Episode`, `Translator`, `Composition` в Prisma.
    *   Создана базовая админ-панель для CRUD-операций с контентом (`/admin/series`, `/admin/translators`).

*   **Коммит 1.4: `feat(player): implement basic player page`**
    *   Создана страница плеера `/series/[id]` для отображения эпизодов.
    *   Реализован выбор сезона, эпизода и доступного перевода (`Composition`).

*   **Коммит 1.5: `feat(async-poc): implement proof-of-concept async processing`**
    *   Реализованы модели `Upload` (устаревшая) и `MediaStream` (устаревшая).
    *   Настроена система очередей BullMQ для фоновых задач.
    *   Создан независимый процесс-воркер (`worker.ts`), способный:
        *   Скачивать файлы по URL (`yt-dlp`).
        *   Демультиплексировать их на видео/аудио потоки (`ffmpeg`).
        *   Загружать результирующие файлы в S3-хранилище (MinIO).
    *   Создан UI для добавления URL в очередь на обработку (`/account/uploads`).
    *   *Примечание:* Функционал данного коммита будет переработан и заменен в последующих спринтах на новую архитектуру `FileAsset`.

---

## **Спринт 2: Фундамент — Единая система файлов (`FileAsset`) и Прямая загрузка**

**Цель:** Провести глобальный рефакторинг, заменив устаревшие модели `Upload` на новую, унифицированную систему `FileAsset` и реализовав современный механизм прямой загрузки файлов в S3.

*   **Коммит 2.1: `refactor(prisma): implement unified FileAsset model`**
    *   Полностью переписать схему Prisma:
        *   Ввести центральную модель `FileAsset` с полями `uuid`, `originalFilename`, `s3Key`, `sizeBytes`, `mimeType`, `status`, `assetType`.
        *   Ввести мета-модели `MediaFileMeta` (связь 1-к-1 с `FileAsset` для медиа-файлов) и `PersonalFileMeta` (связь 1-к-1 для личных файлов).
        *   Создать модель `PersonalFolder` для иерархии личного хранилища.
        *   Модифицировать модель `MediaStream`, чтобы она ссылалась на `MediaFileMeta` и включала `qualityLabel`, `codecInfo`, `language`.
        *   Удалить устаревшую модель `Upload` и соответствующую логику.
    *   Обновить все связанные `types` на фронтенде (`types/index.ts`).
    *   Создать новую, чистую миграцию БД (`npx prisma migrate dev --name init_fileasset_model`).

*   **Коммит 2.2: `feat(api): implement DIRECT upload workflow`**
    *   Создать новый API-эндпоинт `POST /api/v1/assets/request-upload-url`.
    *   **Payload:** `{ filename: string, sizeBytes: number, mimeType: string, assetType: AssetType, folderId?: number }`.
    *   **Логика:**
        1.  Генерирует уникальный S3 ключ для временного размещения файла (например, `temp/{uuid}/original_filename.ext`).
        2.  Создает запись `FileAsset` (и соответствующую `MediaFileMeta` или `PersonalFileMeta`) со статусом `PENDING`.
        3.  Генерирует pre-signed URL для `PUT` запроса на этот S3 ключ.
        4.  Возвращает `assetId`, `uploadUrl` и `s3Key` клиенту.

*   **Коммит 2.3: `feat(api): implement upload finalization`**
    *   Создать новый API-эндпоинт `POST /api/v1/assets/[id]/finalize-upload`.
    *   **Payload:** `{ s3Key: string }`.
    *   **Логика:**
        1.  Клиент вызывает этот эндпоинт после успешной загрузки файла в S3 по pre-signed URL.
        2.  Сервер проверяет, что файл по предоставленному `s3Key` действительно существует и соответствует `FileAsset` по `assetId`.
        3.  **Перемещает** файл из временного расположения (`temp/`) в постоянное (например, `personal/{userId}/...` или `media/sources/{uuid}/...`).
        4.  Обновляет поле `s3Key` в записи `FileAsset` на новый постоянный путь.
        5.  Если `FileAsset.assetType` === `MEDIA_SOURCE`, меняет его `status` на `PROCESSING` и **ставит новую задачу в очередь BullMQ** (`process-media-job`) для дальнейшей медиа-обработки.
        6.  Если `FileAsset.assetType` === `PERSONAL`, меняет его `status` на `AVAILABLE`.
        7.  Возвращает финальный статус `FileAsset`.

*   **Коммит 2.4: `feat(ui): create Personal Storage UI`**
    *   Создать новую страницу `pages/account/storage/`.
    *   Реализовать UI для личного хранилища: отображение иерархии папок и файлов, навигация ("хлебные крошки").
    *   Интегрировать новую логику **прямой загрузки файлов с диска** через API `request-upload-url` и `finalize-upload`.
    *   Реализовать UI для создания папок, переименования, удаления и перемещения файлов/папок (по возможности drag-n-drop).

---

## **Спринт 3: Серверные загрузки по URL**

**Цель:** Реализовать механизм, при котором сервер сам скачивает контент по URL, предоставленному клиентом.

*   **Коммит 3.1: `feat(api, worker): implement URL download workflow`**
    *   Создать новый API-эндпоинт `POST /api/v1/assets/download-from-url`.
    *   **Payload:** `{ sourceUrl: string, assetType: AssetType, folderId?: number }`.
    *   **Логика:**
        1.  Создает запись `FileAsset` (и соответствующую `MediaFileMeta` или `PersonalFileMeta`) со статусом `PENDING`.
        2.  **Сразу ставит задачу в очередь BullMQ** (`download-url-job`), передавая `assetId` и `sourceUrl`.
        3.  Возвращает `assetId` клиенту для отслеживания статуса.
    *   **Воркер:** Создать обработчик для `download-url-job`.
        1.  Читает `sourceUrl` из `FileAsset`.
        2.  Обновляет статус `FileAsset` на `PROCESSING`.
        3.  Скачивает файл с `sourceUrl` (используя `yt-dlp`) напрямую в постоянное S3-хранилище (или во временную папку, а затем перемещает в S3).
        4.  Обновляет `s3Key` и `status` `FileAsset`.
        5.  Если `assetType` === `MEDIA_SOURCE`, ставит следующую задачу на медиа-обработку (`process-media-job`).
        6.  Если `assetType` === `PERSONAL`, меняет статус на `AVAILABLE`.

*   **Коммит 3.2: `feat(ui): add URL download option to UI`**
    *   На страницах `/account/storage` и/или новой `/account/media-assets` добавить UI-элементы (вкладки/кнопки) для загрузки по URL, которые будут вызывать новый API-эндпоинт `download-from-url`.

---

## **Спринт 4: Медиа-конвейер на новой архитектуре**

**Цель:** Полностью адаптировать систему обработки медиа для работы с новой моделью `FileAsset`, обеспечивая функциональность, аналогичную Спринту 1.

*   **Коммит 4.1: `refactor(worker): adapt media processing to FileAsset`**
    *   Переписать основной медиа-процессинг в воркере (обработчик для `process-media-job`).
    *   **Логика:**
        1.  Получает `assetId` из очереди.
        2.  Находит `FileAsset` и связанный `MediaFileMeta`.
        3.  Скачивает исходный файл из S3 во временную папку.
        4.  Выполняет демультиплексирование/транскодирование (`ffmpeg`, `ffprobe`) в соответствии с дефолтными настройками.
        5.  Для каждого производного потока (видео, аудио, субтитры) загружает его в S3.
        6.  Создает записи `MediaStream` и связывает их с `MediaFileMeta`, указывая `qualityLabel`, `codecInfo`, `language`.
        7.  Обновляет статус `FileAsset` на `AVAILABLE` или `ERROR`.
        8.  Очищает временную папку.

*   **Коммит 4.2: `refactor(ui): update media asset management`**
    *   Переименовать и переработать страницу `/account/uploads` в `/account/media-assets`.
    *   Она теперь отображает список `FileAsset` с `assetType: MEDIA_SOURCE` и их статусы обработки.
    *   Реализовать фильтрацию по статусу, дате.

*   **Коммит 4.3: `feat(ui): implement Media Asset configuration`**
    *   На странице отдельного медиа-ассета (`/account/media-assets/[id]`) реализовать UI для привязки его к эпизоду (`linkedEpisodeId` в `MediaFileMeta`).
    *   Реализовать конструктор `Composition` из производных потоков (`MediaStream`), используя доступные видео- и аудио-потоки данного `MediaFileMeta` и других `MediaFileMeta`, привязанных к тому же эпизоду.

---

## **Спринт 5: Плеер и Продвинутый UX**

**Цель:** Восстановить функционал плеера на новой архитектуре и значительно улучшить удобство использования.

*   **Коммит 5.1: `refactor(player): integrate player with new models`**
    *   Адаптировать страницу плеера `/series/[id]` и API-эндпоинт `translations.get.ts` для работы с новыми моделями (`FileAsset` -> `MediaFileMeta` -> `MediaStream` -> `Composition`).
    *   Убедиться, что плеер корректно получает URL-ы к потокам в S3.

*   **Коммит 5.2: `feat(player): implement subtitle support`**
    *   Расширить логику воркера для извлечения субтитров и сохранения их как `MediaStream` с `type: SUBTITLE`.
    *   Обновить эндпоинт `translations.get.ts`, чтобы он включал пути к файлам субтитров в `player_config`.
    *   UI создания `Composition` должен позволять опционально добавлять к сборке один или несколько потоков субтитров.
    *   Плеер должен уметь отображать эти субтитры.

*   **Коммит 5.3: `feat(ux): enhance series page experience`**
    *   На странице `/series/[id]` реализовать логику:
        *   При первой загрузке автоматически выбирать первый сезон и первый эпизод.
        *   Сохранять последний просмотренный эпизод и переводчика в `localStorage` и восстанавливать этот выбор при повторном заходе.

*   **Коммит 5.4: `feat(admin): improve content management UX`**
    *   **Управление пользователями:** Создать страницу `/admin/users.vue` с таблицей пользователей. Реализовать API для получения списка пользователей и изменения их роли.
    *   **Управление метаданными:** Расширить `AdminSeriesForm` и `AdminEpisodeForm`, добавив поля для управления метаданными (год выпуска, студия, жанры и т.д. - добавить в Prisma-схему).
    *   **Автовыбор:** При открытии модального окна для создания нового эпизода, поля "Сезон" и "Эпизод" должны быть автоматически предзаполнены следующими по порядку номерами.

*   **Коммит 5.5: `feat(compositions): allow null translator`**
    *   В схеме Prisma сделать связь `translator` в модели `Composition` опциональной (`translatorId Int?`).
    *   Обновить API и UI, чтобы можно было создавать сборку, не указывая переводчика. Название `composition.name` в таком случае можно генерировать автоматически (например, "Аудио #123").

---

## **Спринт 6: Продвинутая Конвертация и Настройка**

**Цель:** Добавить возможность настройки форматов, в которые будут конвертироваться медиа-файлы.

*   **Коммит 6.1: `feat(config): implement configuration backend`**
    *   Реализовать бэкенд для загрузки параметров из конфига и их сохранения.
    *   Реализовать отображение соответствующей странице в админ-панеле.
    *   Проверить существующие и добавить новые параметры (названия, пути, ключи).

*   **Коммит 6.2: `feat(config): implement transcoding options`**
    *   Реализовать новые параметры для настройки применяемых форматов для транскодирования видео и аудио. Например, по умолчанию видео сохраняется в двух качествах: 1080p AV1 ~ 3 mbps, 1080p H264 5 mbps, а аудио в OPUS ~ 224 kbps.
    *   Реализовать настройки для дублирования видео в несколько кодеков (помимо настройки разрешений) для повышения совместимости.
    *   В этих параметрах указываются специфические параметры `ffmpeg`. Для удобства использования можно создать пресеты.
    *   Реализовать параметры итогового формата (HLS или нет, какой контейнер?).

*   **Коммит 6.3: `refactor(worker): implement dynamic transcoding`**
    *   Изменить воркер так, чтобы он, читая актуальный конфиг, транскодировал видео, аудио, субтитры в соответствующие форматы и создавал несколько `MediaStream` для каждого исходного потока.

*   **Коммит 6.4: `feat(player): add quality options to player`**
    *   Изменить генерацию плеера так, чтобы он указывал различные качества (`[FHD]ссылка,[HD]ссылка,...`).
    *   Реализовать автоматическое определение поддерживаемых кодеков для клиента, если это необходимо.

---

## **Спринт 7: Мультиязычность и Пакетные Операции**

**Цель:** Добавить поддержку нескольких языков для интерфейса и расширить возможности пакетной работы с контентом.

*   **Коммит 7.1: `feat(translations): add language fields to models`**
    *   Добавить поле `language` в модели `MediaStream` и `Composition`.
    *   Добавить UI для указания языка и его автоопределения из метаданных (для медиа-файлов).

*   **Коммит 7.2: `feat(i18n): implement UI internationalization`**
    *   Интегрировать библиотеку для i18n (например, `@nuxtjs/i18n`).
    *   Обернуть все строки в интерфейсе в функции перевода.
    *   Реализовать меню для выбора языка интерфейса.
    *   Реализовать отображение всех строк непосредственно в админ-панели и добавить возможность админам редактировать их.

*   **Коммит 7.3: `feat(ui): implement language selection for compositions`**
    *   На странице сериала: реализовать автовыбор языка перевода для пользователя, делать серыми и перемещать в конец списка те переводы, которые на языке, отличном от пользовательского.

*   **Коммит 7.4: `feat(batch): implement advanced batch composition creation`**
    *   Создать новый UI (возможно, на отдельной странице `/account/media-assets/batch-compositions`) или расширить существующий.
    *   Позволяет пользователю выбрать несколько `MediaFileMeta` (завершенных загрузок). Затем он создает "шаблон" сборки для первой загрузки (выбирает аудио-поток, видео-поток, переводчика).
    *   Новый эндпоинт `POST /api/v1/account/compositions/batch-create`.
    *   Для каждой последующей загрузки он пытается найти соответствующие потоки и создает по этому шаблону новую `Composition` для соответствующего эпизода.

---

## **Спринт 8: Финальная полировка и Подготовка к Production**

**Цель:** Добавить последние штрихи, которые делают приложение готовым к реальному использованию.

*   **Коммит 8.1: `feat(ui): implement notification system`**
    *   Внедрить систему всплывающих уведомлений (Toasts) для всех операций.

*   **Коммит 8.2: `feat(ux): real-time status updates with SSE`**
    *   Реализовать SSE (Server-Sent Events) для мгновенного обновления статусов `FileAsset` на страницах личного хранилища и медиа-активов без перезагрузки.

*   **Коммит 8.3: `refactor(config): externalize all settings`**
    *   Провести финальный аудит кода. Убедиться, что все настраиваемые параметры (пути, лимиты, доступы) вынесены в `runtimeConfig` и управляются через `.env`.

*   **Коммит 8.4: `docs(setup): create deployment documentation`**
    *   Начать писать подробную документацию по развертыванию приложения (настройка VPS, Reverse Proxy, запуск Docker-контейнеров, настройка MinIO).

---

## **Спринт 9: Интеграция Торрентов (Продвинутый функционал)**

**Цель:** Реализовать комплексную систему загрузки файлов из торрентов, решив задачи повторного добавления, обработки метаданных и многопользовательского доступа.

*   **Коммит 9.1: `feat(api): implement Torrent download workflow`**
    *   Добавить торрент-клиент (Transmission) в `docker-compose.yml`.
    *   Создать API-эндпоинты для добавления magnet-ссылки, получения списка файлов из торрента и запуска скачивания.

*   **Коммит 9.2: `feat(worker): add torrent processing support`**
    *   **Воркер:** Создать обработчик для `process-torrent-job`.
    *   **Логика:**
        1.  Взаимодействует с API торрент-клиента (Transmission) для добавления торрента на закачку.
        2.  Периодически опрашивает статус закачки через API Transmission.
        3.  Когда закачка завершена (или выбранные файлы скачаны), воркер сканирует папку с результатами торрент-клиента.
        4.  **Для каждого скачанного медиа-файла** он создает отдельную запись `FileAsset` с `assetType: MEDIA_SOURCE`, загружает его в S3 и ставит стандартную задачу на медиа-обработку (`process-media-job`).
        5.  **Для каждого скачанного личного файла** он создает `FileAsset` с `assetType: PERSONAL`, загружает в S3 и меняет статус на `AVAILABLE`.

*   **Коммит 9.3: `feat(ui): add torrent download UI`**
    *   Создать UI для вставки Magnet-ссылки, получения списка файлов и выбора нужных для скачивания.

*   **Коммит 9.4: `refactor(queue): implement robust torrent job handling`**
    *   Реализовать надежную логику обработки задач для торрентов в BullMQ.
    *   Разработать стратегию для обработки повторного добавления одного и того же торрента (например, находить существующую задачу или создавать новую с уникальным идентификатором).
    *   Продумать сценарий, когда несколько пользователей добавляют один и тот же торрент.