### Обновленная и скорректированная дорожная карта разработки

**Основная цель:** Поэтапно перейти от текущего мокапа к полнофункциональному MVP, работающему с реальной базой данных и асинхронной обработкой файлов, следуя вашим 19 принципам.

---

### Спринт 0: Конфигурация и подготовка проекта

**Цель спринта:** Создать централизованный файл конфигурации и подготовить проект к работе с реальными данными, отказавшись от хардкода.

**Задачи:**

1.  **Создание файла конфигурации:**
    *   Создать файл `config.json` (или `app.config.ts` для типизации) в корне проекта.
    *   Вынести в него базовые настройки:
        *   Название сайта.
        *   Настройки по умолчанию для воркеров (например, пути к временным папкам).
        *   Настройки для API (например, ключ для JWT, срок жизни токена).
        *   Пути к `ffmpeg` и `ffprobe`, если они не в системном PATH.
    *   Создать composable `useAppConfig()` для легкого доступа к этой конфигурации в приложении.

2.  **Подготовка к работе с БД:**
    *   Запустить локально PostgreSQL и Redis (например, через Docker Desktop).
    *   Установить Prisma (`npm install prisma --save-dev`).
    *   Инициализировать Prisma в проекте (`npx prisma init`). В `prisma/.env` указать данные для подключения к вашей локальной БД.

3.  **Проектирование схемы БД:**
    *   В `prisma/schema.prisma` описать все модели (`User`, `Series`, `Episode`, `Upload`, `MediaStream`, `Composition`, `Translator`) и связи между ними.
    *   **Особое внимание:** Модель `Composition` должна гибко связывать один `MediaStream` (video) и один `MediaStream` (audio), подтверждая **Принципы 5-8**.
    *   Запустить первую миграцию (`npx prisma migrate dev --name init`).

**Результат спринта:** Проект сконфигурирован, схема данных определена, база данных готова к наполнению. Фундамент заложен.

---

### Спринт 1: Реализация API-ядра и Аутентификации

**Цель спринта:** Полностью перевести бэкенд с моков на реальную базу данных.

**Задачи:**

1.  **Создание Prisma-клиента:**
    *   Создать утилиту `server/utils/prisma.ts` для инициализации и экспорта синглтона Prisma-клиента.

2.  **Переписывание API-эндпоинтов:**
    *   Переписать все эндпоинты в `server/api/v1/` для использования Prisma-клиента вместо работы с массивами из `server/data/db.ts`.
    *   **Удалить папку `server/data/`**, так как она больше не нужна.

3.  **Реализация настоящей Аутентификации:**
    *   **API:**
        *   `server/api/v1/auth/register.post.ts`: Хеширование пароля (`bcrypt`) перед сохранением в БД.
        *   `server/api/v1/auth/login.post.ts`: Сравнение хеша и генерация настоящего JWT (`jsonwebtoken`).
    *   **Middleware:**
        *   Создать middleware `server/middleware/auth.ts` (не global), который будет проверять JWT, извлекать `userId` и добавлять в контекст запроса (`event.context.user`). Это обеспечит безопасность всех защищенных эндпоинтов.

**Результат спринта:** Приложение имеет полнофункциональный, безопасный и персистентный бэкенд.

---

### Спринт 2: Асинхронная обработка URL и демультиплексирование

**Цель спринта:** Реализовать базовый, но полный цикл асинхронной обработки файлов, включая их разделение на потоки.

**Задачи:**

1.  **Настройка очереди задач:**
    *   Установить `bullmq`.
    *   Создать утилиту `server/utils/queue.ts` для работы с очередью.

2.  **Изменение API загрузки (`server/api/v1/uploads/index.post.ts`):**
    *   При получении запроса на загрузку по URL, API теперь только создает запись `Upload` в БД со статусом `'new'` и добавляет задачу в очередь BullMQ.

3.  **Создание воркера (`worker.ts` на Node.js/TS):**
    *   **Логика обработки задачи `process-url`:**
        1.  Обновляет статус `Upload` в БД на `'downloading'`.
        2.  Скачивает файл с помощью `yt-dlp`.
        3.  Обновляет статус на `'processing'`.
        4.  **Реализация "разбиения" (Принцип 18):** С помощью `ffmpeg` разделяет контейнер на отдельные файлы-потоки (`video-stream.mkv`, `audio-stream-1.mka` и т.д.).
        5.  Для каждого извлеченного файла:
            *   Загружает его в S3 (локальный MinIO).
            *   Создает соответствующую запись `MediaStream` в БД через Prisma, связывая ее с исходным `Upload`.
        6.  Обновляет статус `Upload` на `'completed'`.

4.  **UI (`pages/account/uploads/index.vue`):**
    *   UI должен корректно отображать статусы (`new`, `downloading`, `processing`, `completed`, `error`), получаемые из БД. Поллинг можно пока оставить.

**Результат спринта:** Приложение умеет асинхронно обрабатывать файлы по URL и подготавливать их для дальнейшей работы (создания сборок).

---

### Спринт 3: Поддержка торрентов и базовый UI управления

**Цель спринта:** Расширить возможности загрузки и дать пользователю базовые инструменты для работы с обработанными файлами.

**Задачи:**

1.  **Интеграция торрент-клиента:**
    *   Добавить в `docker-compose.yml` сервис `transmission` или `qbittorrent`.

2.  **Обновление API и Воркера:**
    *   API `uploads.post.ts` теперь принимает `magnet`-ссылки.
    *   Воркер получает новый тип задачи `process-torrent`, который взаимодействует с API торрент-клиента для скачивания, а затем запускает тот же процесс демультиплексирования, что и в Спринте 2.

3.  **UI управления сборками (`pages/account/uploads/[uuid].vue`):**
    *   После того как `Upload` получает статус `'completed'`, на этой странице должны отображаться все извлеченные из него `MediaStream` (видео, аудио, субтитры).
    *   Реализовать UI для создания `Composition`: пользователь выбирает один видеопоток, один аудиопоток и переводчика, после чего создается запись в БД.

**Результат спринта:** Система поддерживает два основных типа источников. Пользователь может не только загружать, но и создавать первые "сборки".

---

### Спринт 4: Плеер и интерактивность

**Цель спринта:** Замкнуть основной пользовательский цикл — от загрузки до просмотра.

**Задачи:**

1.  **Интеграция видеоплеера (`pages/series/[id].vue`):**
    *   Добавить на страницу компонент плеера (например, Player.js).
    *   При выборе пользователем "перевода" (т.е. `Composition`), плеер инициализируется с публичными URL на соответствующие видео- и аудиопотоки из S3.

2.  **Базовая синхронизация ("монтаж"):**
    *   В UI создания/редактирования `Composition` добавить числовое поле "Задержка аудио (мс)".
    *   Это значение сохраняется в БД и передается в конфигурацию плеера.

3.  **Система уведомлений (Toasts):**
    *   Заменить все `alert()` на централизованную систему всплывающих уведомлений для более качественной обратной связи.

**Результат спринта:** Приложение выполняет свою главную функцию — позволяет смотреть скомпонованный контент. **Это функциональный MVP.**

---

### Спринт 5: Инструменты массового управления и администрирования

**Цель спринта:** Предоставить инструменты для эффективного наполнения и управления контентом.

**Задачи:**

1.  **Пакетная настройка (`pages/account/uploads/batch-edit.vue`):**
    *   Реализовать полнофункциональный UI с Drag-and-Drop для сортировки загрузок.
    *   API-эндпоинт `batch-configure` должен уметь массово создавать `Compositions` на основе порядка загрузок и выбранных эпизодов.

2.  **Админ-панель (`pages/admin/**`):**
    *   Реализовать полный CRUD-функционал для всех сущностей (`Series`, `Translators`, `Users`) через соответствующие API.

3.  **Прототип парсера:**
    *   Создать API-эндпоинт, который по ID с внешнего ресурса (Shikimori/IMDB) может получить и создать в БД структуру сезонов и эпизодов для сериала.

**Результат спринта:** Приложение становится удобным для массового наполнения, что критически важно для роста медиатеки.