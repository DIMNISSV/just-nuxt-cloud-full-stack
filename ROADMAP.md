
### **Обновленная дорожная карта (после Спринта 1)**

#### **Спринт 2: Запуск асинхронной обработки файлов (URL)**

**Цель:** Заставить приложение **автоматически** обрабатывать загрузки, скачивать файлы и разделять их на потоки. Это "оживит" страницы настройки.

*   **Коммит 2.1: `feat(queue): implement BullMQ for background jobs`**
    *   Установить `bullmq`.
    *   Создать утилиту `server/utils/queue.ts`.
    *   Изменить API `account/uploads/index.post.ts`: теперь он не создает потоки, а только ставит задачу в очередь Redis.

*   **Коммит 2.2: `feat(worker): create initial worker for URL processing`**
    *   Создать базовый процесс-воркер (`worker.ts`).
    *   Реализовать в нем логику скачивания файла по URL (`yt-dlp`).
    *   Реализовать **демультиплексирование** с помощью `ffmpeg` для разделения видео на отдельные потоки (видео, аудио, субтитры).
    *   Реализовать загрузку каждого извлеченного потока в S3 (MinIO).
    *   Реализовать создание записей `MediaStream` в БД для каждого потока с путем к файлу в S3.
    *   Реализовать обновление статуса `Upload` на `COMPLETED` или `ERROR`.

*   **Коммит 2.3: `feat(types): add subtitle support to models`**
    *   Добавить поддержку субтитров в схему Prisma (`MediaStream` `type: SUBTITLE`).
    *   Обновить `types/index.ts`.
    *   Воркер должен уметь извлекать и сохранять субтитры (`.srt`, `.ass` и т.д.).

*   **Коммит 2.4: `feat(uploads): add video files direct upload support`**
    *   В дополнение к загрузке по URL реализовать загрузку файлов с ПК пользователя.
    *   Реализовать загрузку сразу нескольких файлов.

---

#### **Спринт 3: Расширение обработки (Торренты) и базовый плеер**

**Цель:** Добавить поддержку торрентов и замкнуть основной цикл, дав пользователю возможность просмотра.

*   **Коммит 3.1: `feat(worker): add torrent processing support`**
    *   Добавить торрент-клиент (Transmission) в `docker-compose.yml`.
    *   Обновить API `uploads.post.ts` для приема `magnet`-ссылок. Необходимо учесть и то, что торрент может содержать в себе папку.
    *   Расширить воркер: добавить новый тип задачи `process-torrent`, который взаимодействует с API торрент-клиента, а после скачивания запускает ту же логику демультиплексирования.

*   **Коммит 3.2: `feat(ui): add torrent upload UI`**
    *   Если пользователь загружает торрент, нужно добавить UI с его метаданными (например, автоматически при указании источника magnet-ссылкой или торрент файла. Надо учесть и то, что пользователь может указать несколько magnet-ссылок подряд: тогда нужно отображать метаданные последовательно или через селектор.
    *   В этом UI пользователь может указать какие эпизоды загружать, а какие нет. Возможно, может переименовать их.

*   **Коммит 3.3: `feat(ui): integrate video player`**
    *   На странице `/series/[id].vue` добавить компонент плеера (Player.js).
    *   При выборе перевода (`Composition`) инициализировать плеер с URL на видео и аудио из S3.

*   **Коммит 3.4: `feat(player): implement subtitle logic` (Ваш пункт 3)**
    *   Обновить эндпоинт `player/.../translations.get.ts`, чтобы он включал в `player_config` пути к файлам субтитров, если они есть.
    *   UI создания `Composition` должен позволять опционально добавлять к сборке один или несколько потоков субтитров.
    *   Плеер должен уметь отображать эти субтитры.

*   **Коммит 3.5: `feat(ui): implement tags and folders for uploads`**
    *   Концептуально это не влияет на логику, но пользователю будет удобнее организовывать файлы внутри своего личного кабинета.
    *   Также, при загрузке торрента удобно помещать его в отдельную папку.
    *   При этом, пользователю нужен drag-n-drop интерфейс, чтобы перетаскивать файлы из папки в папку.
    *   Реализовать соответствующие поля в моделях, а также возможность поместить файлы в папку при загрузке.

---

#### **Спринт 4: Продвинутый UX и управление**

**Цель:** Значительно улучшить удобство использования приложения на основе вашего фидбека.

*   **Коммит 4.1: `feat(ux): enhance series page experience`**
    *   На странице `/series/[id].vue` реализовать логику:
        *   При первой загрузке автоматически выбирать первый сезон и первый эпизод.
        *   Сохранять последний просмотренный эпизод и переводчика в `localStorage` и восстанавливать этот выбор при повторном заходе.

*   **Коммит 4.2: `feat(admin): improve content management UX`**
    *   **Управление пользователями:** Создать страницу `/admin/users.vue` с таблицей пользователей. Реализовать API для получения списка пользователей и изменения их роли.
    *   **Управление метаданными:** Расширить `AdminSeriesForm` и `AdminEpisodeForm`, добавив поля для управления метаданными (год выпуска, студия, жанры и т.д. - добавить в Prisma-схему).
    *   **Автовыбор:** При открытии модального окна для создания нового эпизода, поля "Сезон" и "Эпизод" должны быть автоматически предзаполнены следующими по порядку номерами.

*   **Коммит 4.3: `feat(compositions): allow null translator`**
    *   В схеме Prisma сделать связь `translator` в модели `Composition` опциональной (`translatorId Int?`).
    *   Обновить API и UI, чтобы можно было создавать сборку, не указывая переводчика. Название `composition.name` в таком случае можно генерировать автоматически (например, "Аудио #123").

*   **Коммит 4.4: `feat(batch): implement advanced batch composition creation`**
    *   **Это сложная задача.** Создать новый UI (возможно, на отдельной странице `/account/uploads/batch-compositions`) или расширить существующий.
    *   **UI:** Позволяет пользователю выбрать несколько "завершенных" загрузок. Затем он создает "шаблон" сборки для первой загрузки (выбирает аудио-поток, видео-поток, переводчика).
    *   **API:** Создать новый эндпоинт `POST /api/v1/account/compositions/batch-create`.
    *   **Логика API:** Принимает список `uploadId` и "шаблон". Для каждой последующей загрузки он пытается найти соответствующие потоки (например, первый аудио-поток и первый видео-поток) и создает по этому шаблону новую `Composition` для соответствующего эпизода.
    *   **Доработка:** Необходимо решить по какой логике искать равки по шаблону в следующих сериях, если просто по порядковому номеру уже не сработает (как мы могли бы сделать, если равка и аудио из одного и того же файла).
---

#### **Спринт 5: Финальная полировка и подготовка к Production**

**Цель:** Добавить последние штрихи, которые делают приложение готовым к реальному использованию.

*   **Коммит 5.1: `feat(ui): implement notification system`**
    *   Внедрить систему всплывающих уведомлений (Toasts) для всех операций.

*   **Коммит 5.2: `feat(ux): real-time upload status updates`**
    *   Реализовать SSE (Server-Sent Events) для мгновенного обновления статусов загрузок на странице `/account/uploads` без перезагрузки.

*   **Коммит 5.3: `refactor(config): externalize all settings`**
    *   Провести финальный аудит кода. Убедиться, что все настраиваемые параметры (пути, лимиты и т.д.) вынесены в `nuxt.config.ts` / `app.config.ts`.

*   **Коммит 5.4 (Начало): `docs(setup): create deployment documentation`**
    *   Начать писать документацию по развертыванию (настройка VPS, Reverse Proxy, запуск Docker-контейнеров).
