# **Project Roadmap: `just-nuxt-cloud-full-stack`**

Это дорожная карта развития проекта `just-nuxt-cloud-full-stack`, облачной платформы для хранения и обработки файлов. Рабочее имя сервиса — `jcloud.me`.

## **Пре-Спринт: Архитектурный Рефакторинг (Текущий этап)**

**Цель:** Заложить фундаментальную, масштабируемую архитектуру, основанную на сервис-ориентированном подходе. Создать универсальный "Сервис Хранилища" как ядро всей платформы.

*   **Коммит 0.1: `refactor(prisma): introduce unified StorageNode model`**
    *   Провести полный рефакторинг схемы Prisma.
    *   Удалить модели `FileAsset`, `PersonalFileMeta`, `MediaFileMeta`, `PersonalFolder`.
    *   Ввести единую центральную модель **`StorageNode`** (`type: 'FILE' | 'FOLDER'`), которая будет представлять любой объект в хранилище и поддерживать иерархию (`parentId`).
    *   Все "физические" атрибуты (`s3Key`, `mimeType`, `sizeBytes`, `status`) перенести в `StorageNode`.
    *   Создать связующую модель `EpisodeMediaSource` для привязки исходников к эпизодам.
    *   Обновить модель `Composition`, чтобы она ссылалась напрямую на `StorageNode` для видео и аудио потоков.
    *   Создать новую, чистую миграцию БД, отражающую новую архитектуру.

*   **Коммит 0.2: `refactor(api): create isolated Storage Service API`**
    *   Создать новый, изолированный набор API-эндпоинтов в директории `/api/v1/storage/`.
    *   Реализовать базовые CRUD-операции для `StorageNode`:
        *   `GET /nodes/{id}`: Получить информацию об узле (файле или папке).
        *   `GET /nodes/{id}/children`: Получить список дочерних узлов.
        *   `POST /nodes`: Создать новый узел (папку или пустой файл).
        *   `PUT /nodes/{id}`: Обновить метаданные узла.
        *   `DELETE /nodes/{id}`: Удалить узел.
    *   Весь код, работающий с S3, должен быть инкапсулирован внутри этого "сервиса".

*   **Коммит 0.3: `refactor(project): update naming and documentation`**
    *   Изменить название проекта на `just-nuxt-cloud-full-stack`.
    *   Обновить `package.json`, `README.md` и другие документы.
    *   В UI заменить старое название "MediaServer" на новое, например, **`jCloud`** или `jcloud.me`.
    *   Обновить заголовки страниц, футер и другие элементы интерфейса.

## **Спринт 1: Базовый Функционал Хранилища и Прямая Загрузка**

**Цель:** Реализовать основной пользовательский сценарий — работу с файлами и папками в личном хранилище с прямой загрузкой с диска.

*   **Коммит 1.1: `feat(api): implement direct upload workflow via Storage Service`**
    *   Создать API-эндпоинты в рамках Сервиса Хранилища для управления прямой загрузкой:
        *   `POST /storage/nodes/request-upload-url`: Принимает `parentId` и `filename`, создает `StorageNode` со статусом `PENDING` и возвращает pre-signed URL.
        *   `POST /storage/nodes/{id}/finalize-upload`: Проверяет наличие файла в S3, перемещает его в постоянное хранилище и обновляет статус `StorageNode` на `AVAILABLE`.

*   **Коммит 1.2: `feat(ui): implement Personal Storage UI on new architecture`**
    *   Создать страницу "Мой Диск" (`/drive`).
    *   Реализовать UI для навигации по папкам (`StorageNode` с типом `FOLDER`).
    *   Интегрировать новую логику прямой загрузки файлов (`StorageNode` с типом `FILE`) через API Сервиса Хранилища.
    *   Реализовать UI для создания папок, переименования и удаления `StorageNode`.

*   **Коммит 1.3: `feat(auth): initial project setup and user authentication`**
    *   Настроена базовая структура проекта Nuxt 3.
    *   Интегрирован `docker-compose.yml` с сервисами: PostgreSQL, Redis, MinIO.
    *   Реализованы модели `User` и `Role` в схеме Prisma.
    *   Созданы API-эндпоинты для регистрации и логина.
    *   Интегрирована аутентификация на основе JWT.
    *   Реализованы middleware для защиты роутов.

## **Спринт 2: Загрузка по URL и Интеграция с Воркером**

**Цель:** Добавить возможность загрузки файлов по URL и настроить взаимодействие API с фоновым воркером.

*   **Коммит 2.1: `feat(api, worker): implement URL download workflow`**
    *   Создать API-эндпоинт `POST /storage/nodes/create-from-url`.
    *   **Логика:** Принимает `sourceUrl` и `parentId`, создает `StorageNode` со статусом `PENDING` и ставит задачу в очередь BullMQ, передавая `nodeId`.
    *   **Воркер:** Создать обработчик для `download-url-job`.
        1.  Получает `nodeId`.
        2.  Скачивает файл с `sourceUrl`.
        3.  Загружает его в S3.
        4.  **Вызывает API** `PUT /storage/nodes/{id}` для обновления `s3Key`, `sizeBytes` и установки статуса `AVAILABLE`.

*   **Коммит 2.2: `feat(ui): add URL download option to Drive UI`**
    *   На странице "Мой Диск" добавить UI (кнопку, модальное окно) для загрузки по URL, который будет вызывать новый API-эндпоинт.
    *   Реализовать отображение статусов (`PENDING`, `PROCESSING`, `ERROR`) для `StorageNode` в UI.

## **Спринт 3: Приложение "Медиатека" — Основы**

**Цель:** Создать второе "приложение" на базе Сервиса Хранилища — Медиатеку. Реализовать управление контентом и медиа-конвейер.

*   **Коммит 3.1: `feat(admin): create basic content management for Series/Episodes`**
    *   Создать админ-панель для CRUD-операций с моделями `Series`, `Season`, `Episode`.

*   **Коммит 3.2: `feat(ui): implement media source management`**
    *   Создать UI для "привязки" `StorageNode` (исходного медиа-файла) к `Episode` через создание записи `EpisodeMediaSource`.
    *   Это действие должно инициировать новую задачу в очереди BullMQ — `process-media-job`.

*   **Коммит 3.3: `feat(worker): implement media processing pipeline`**
    *   **Воркер:** Создать обработчик для `process-media-job`.
    *   **Логика:**
        1.  Получает `sourceNodeId` (ID исходного файла).
        2.  Скачивает его из S3.
        3.  Анализирует (`ffprobe`) и демультиплексирует/транскодирует (`ffmpeg`) потоки.
        4.  **Для каждого производного потока** (видео, аудио, субтитры) **создает новый `StorageNode`** через API хранилища, размещая их в специальной системной папке.
        5.  Обновляет метаданные (`meta` JSON) у этих новых узлов, указывая язык, качество и т.д.

*   **Коммит 3.4: `feat(ui): implement Composition builder`**
    *   Создать UI, который позволяет из производных `StorageNode` (видео и аудио потоков) собирать `Composition` и привязывать их к эпизоду.

## **Спринт 4: Плеер и Пользовательский Опыт**

**Цель:** Завершить пользовательский цикл, позволив просматривать собранные медиа-композиции.

*   **Коммит 4.1: `feat(player): integrate player with new architecture`**
    *   Создать страницу плеера `/series/[id]`.
    *   Реализовать API, которое на основе `Composition` будет генерировать конфигурацию для плеера, получая pre-signed URL для `StorageNode` (видео и аудио потоков) через API Сервиса Хранилища.

*   **Коммит 4.2: `feat(ux): enhance series page and Drive experience`**
    *   Реализовать автовыбор первого эпизода, сохранение позиции в `localStorage`.
    *   Внедрить систему уведомлений (`Toast`) для всех операций в приложении.
    *   Реализовать фоновое автообновление статусов файлов на "Моём Диске".

---

## **Спринт 5: Продвинутая Конфигурация и Администрирование**

**Цель:** Дать администраторам инструменты для управления платформой и её пользователями.

*   **Коммит 5.1: `feat(admin): implement User Management`**
    *   Создать UI в админ-панели для просмотра списка всех пользователей.
    *   Реализовать API для изменения роли пользователя (`USER`/`ADMIN`), его блокировки или удаления.

*   **Коммит 5.2: `feat(admin): implement Transcoding Presets`**
    *   Создать модель `TranscodingPreset` в Prisma для хранения настроек `ffmpeg` (например, "1080p AV1", "720p H.264", "Opus 192kbps").
    *   Реализовать CRUD-интерфейс в админ-панели для управления этими пресетами.
    *   Обновить воркер (`process-media-job`) так, чтобы он применял все активные пресеты при обработке медиа-файла, создавая несколько `StorageNode` разного качества.

*   **Коммит 5.3: `feat(player): implement quality selection`**
    *   Обновить API плеера, чтобы оно возвращало список доступных качеств для видео.
    *   Интегрировать в UI плеера меню для переключения качества "на лету".

## **Спринт 6: Приложение "Фотохостинг" и генерация превью**

**Цель:** Продемонстрировать гибкость архитектуры, создав новое приложение "Фотохостинг" на базе существующего Сервиса Хранилища.

*   **Коммит 6.1: `feat(prisma): create Photo entity model`**
    *   Создать новую мета-модель `Photo`, которая будет ссылаться на `StorageNode` и хранить специфичные для фото метаданные (например, EXIF, теги, описание).

*   **Коммит 6.2: `feat(worker): implement thumbnail generation`**
    *   Создать новый тип задачи для воркера — `generate-thumbnail-job`.
    *   Задача будет запускаться после загрузки файла с `mimeType`, соответствующим изображению.
    *   Воркер будет создавать превью нескольких размеров и сохранять их как новые `StorageNode`, связывая их с исходным изображением через поле `meta`.

*   **Коммит 6.3: `feat(ui): create Photo Gallery UI`**
    *   Создать новую страницу (`/gallery`) для просмотра загруженных изображений.
    *   Реализовать UI для загрузки фотографий, их просмотра в виде галереи (с использованием сгенерированных превью) и отображения детальной информации.

## **Спринт 7: Интеграция Торрентов (Продвинутый функционал)**

**Цель:** Вернуться к реализации комплексной системы загрузки файлов из торрентов, используя новую, более гибкую архитектуру.

*   **Коммит 7.1: `feat(api): implement robust Torrent download workflow`**
    *   Вернуть торрент-клиент (Transmission) в `docker-compose.yml`.
    *   Создать API-эндпоинт для добавления magnet-ссылки, который будет создавать "виртуальную" задачу или запись в БД для отслеживания.
    *   Реализовать API для получения списка файлов из торрента и запуска скачивания выбранных файлов, которые будут создаваться как `StorageNode` в специальной системной папке.

*   **Коммит 7.2: `refactor(worker): adapt torrent processing to StorageNode`**
    *   Создать обработчик в воркере, который будет отслеживать завершение скачивания в Transmission.
    *   После скачивания воркер должен переместить файлы из папки Transmission в S3 и обновить соответствующие `StorageNode` (установить статус `AVAILABLE`).

*   **Коммит 7.3: `feat(ui): create torrent download UI`**
    *   Создать пользовательский интерфейс для вставки magnet-ссылки, просмотра списка файлов и выбора нужных для загрузки.

## **Спринт 8: Финальная Полировка и Подготовка к Production**

**Цель:** Добавить последние штрихи, которые делают платформу готовой к реальному использованию.

*   **Коммит 8.1: `feat(ux): implement real-time status updates with SSE`**
    *   Реализовать SSE (Server-Sent Events) для мгновенного обновления статусов `StorageNode` на страницах "Мой Диск" и в админ-панели без необходимости периодического опроса.

*   **Коммит 8.2: `feat(security): implement access control and rate limiting`**
    *   Провести аудит безопасности. Убедиться, что пользователь может получить доступ только к своим `StorageNode`.
    *   Внедрить ограничение на частоту запросов (rate limiting) для ключевых API-эндпоинтов.

*   **Коммит 8.3: `refactor(config): externalize all settings`**
    *   Провести финальный аудит кода. Убедиться, что все настраиваемые параметры (пути, лимиты, доступы) вынесены в `runtimeConfig` и управляются через `.env`.

*   **Коммит 8.4: `docs(setup): create detailed deployment documentation`**
    *   Написать подробную документацию по развертыванию приложения: настройка VPS, Reverse Proxy (Nginx), запуск Docker-контейнеров, настройка MinIO для production, резервное копирование.